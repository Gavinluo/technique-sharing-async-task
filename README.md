# 并发 / 锁 / 版本戳 / 异步 / Task


## 0. 开场（1-2 min）

大家好，今天这 1 小时只讲一个主线：

- **不卡（UI Responsiveness）**：界面不假死，进度可见，能取消  
- **不乱（Correctness）**：并发情况下数据不丢、不乱、不覆盖

我们会用 4 个 Demo 串起来讲——从“为什么会卡”，到“DoEvents 能救急但有坑”，再到“Task/async 正解”，最后把“锁与版本戳”收束成一张决策表。

---

## 1. 统一语言：并发 vs 异步（5 min）

### 我先把两个词拆开讲清楚（避免后面鸡同鸭讲）

- **并发（Concurrency）**：同一段时间里，有多个执行流在推进（可能真并行，也可能交错）
- **异步（Async）**：核心是**不阻塞等待**，尤其是 UI 不要被长任务占住

重要一句话：

> **异步 ≠ 并发**，但异步很容易带来并发（例如按钮点两次，启动了两个任务）。

接下来所有内容都围绕这句话展开。

---

## 2. Demo1：同步长任务为什么会卡死（6 min）

### 现场操作
1. 点击按钮【Sync Work（同步长任务）】
2. 观察：窗口拖动卡、按钮点不动、关闭也不灵、进度条不更新（或极慢）

### 我说的话（台词）
WinForms 的 UI 线程要做两件事：
- 跑我们的事件回调（点击按钮就进来了）
- 处理消息泵：重绘、鼠标、键盘、关闭等

同步长任务把 UI 线程占满了，消息泵处理不了消息，所以就“无响应”。

一句话总结：

> **UI 卡死的根因：UI 线程被长任务占住，消息泵停了。**

---

## 3. Demo2：现状做法——状态栏进度 + DoEvents（8 min）

> 我们现有程序的典型方案：大任务循环里频繁更新底部状态栏+进度条，并调用 DoEvents，让界面“看起来不卡”。

### 现场操作
1. 点击按钮【DoEvents Work（进度 + DoEvents）】
2. 观察：进度条在动，状态栏在变，可以拖动窗口、能点其它按钮

### 我说的话（台词）
DoEvents 做了什么？
- 它会**临时把控制权还给消息泵**，让 UI 去处理待处理的消息（重绘、点击、关闭……）
- 所以你看到：界面“活了”，进度也能刷新

到这一步先别急着否定它——它的确是“救急神器”。

但是（停顿一下）：

> DoEvents 最大的坑不在“刷新 UI”，而在于：它允许**其他 UI 事件在你任务中途插队执行**。

这会引出一个非常隐蔽但非常致命的问题：**重入（Reentrancy）**。

---

## 4. Demo3（反例重点）：DoEvents 引发重入（12-15 min）

### 我先说结论（让大家带着结论看演示）
> DoEvents 不是异步，它更像“开门让消息插队”。  
> 插队的最大风险就是：同一段逻辑没跑完，又被触发一次——**重入**。

### 现场操作（一定要按这个节奏）
1. 点击【DoEvents Work】让任务开始跑（进度条动起来）
2. 在任务中途，连续点击两次【DoEvents Work】（或点一个“再次开始”的按钮）
3. 观察至少一种现象：
   - 日志出现两套任务交错输出（Run#1 / Run#2 混在一起）
   - 进度条回退/跳跃
   - 状态栏显示的 step 明显不可信
   - 资源类操作可能异常（比如文件占用、集合状态异常）
   - 极端情况：卡死（更震撼）

### 我说的话（台词，控制在 3 句话）
- DoEvents 期间消息泵会处理新的 Click 消息
- 新的 Click 再次进入同一段代码（上一次没结束）——这就是**重入**
- 于是共享状态被交错读写，就出现“偶现、难复现”的并发 bug

一句话总结（让同事能复述）：

> **DoEvents 让 UI 活着，也让 bug 活着：重入导致并发问题。**

---

## 5. 先给“止血方案”：不大改也能先安全（5 min）

> 这一段很关键：我们不是说 DoEvents 立刻全删，而是给团队一个“可立刻落地的最小改造”。

### 最小止血三件套（现场讲完就结束，不展开）
1. **运行中禁用开始按钮**（防止重复点击）
2. **加运行标志位/互斥**（二次进入直接 return）
3. **节流 UI 更新频率**（每 50ms 或每 N 次循环再刷新一次）

一句话总结：

> 这能缓解重入，但不是最佳实践；最终要迁移到 Task/async + 进度汇报。

---

## 6. Demo4：Task/async 正解（12-15 min）

### 现场操作
1. 点击【Task Work（async + progress + cancel）】
2. 观察：
   - UI 不阻塞（拖动/点其它按钮正常）
   - 进度条与状态栏持续更新
   - 点【Cancel】能中止任务
   - 任务运行中重复点【Task Work】会被“禁止/排队/提示”（你选择一种实现即可）

### 我说的话（台词）
我们要实现的效果，本质就三件事：
- UI 线程不被占住（不卡）
- 有稳定可靠的进度汇报
- 并发可控：防重复启动 + 可取消

在 WinForms 上，推荐结构是：
- UI 线程：只做事件响应、展示进度、展示结果
- 后台：做耗时工作（Task.Run 或真正异步 IO）
- 进度：用 IProgress/回调切回 UI 更新

一句话总结：

> **async/await 的价值：把“等待”从 UI 线程里拿走，而不是靠 DoEvents 插队。**

---

## 7. 并发正确性：锁 vs 版本戳（8-10 min）

> 到这里大家知道：不卡的方法（DoEvents/async）都可能引入并发。那正确性怎么保证？

### 7.1 锁（悲观并发）：让冲突不发生
适用：同进程共享内存
- lock / Interlocked / 并发容器
强调一句就够：
> 锁只保护临界区；不要在锁里做 IO/等待；锁越小越好。

### 7.2 版本戳（乐观并发）：允许冲突发生但能检测
适用：跨请求、跨线程、跨人编辑
典型：两个窗口同时编辑同一配置，后保存覆盖前保存（丢失更新）
做法：
- 对象带 Version（递增）或 Timestamp
- 保存时校验：版本一致才写入并 +1，否则提示冲突/拒绝/重试

一句话总结：
> 锁解决“同内存竞争”，版本戳解决“跨边界覆盖”。

---

## 8. 最后一页：决策速查表（2 min）

- UI 卡顿：优先 async/await（不要用 DoEvents 当长期方案）
- CPU 大循环：Task.Run + 进度汇报 + 取消
- 防重复启动：按钮禁用 + 互斥（SemaphoreSlim/标志位）
- 内存共享状态：lock / Interlocked / 并发容器
- 跨请求/跨窗口编辑冲突：版本戳（乐观并发）

收尾一句话：

> 工程上永远记住两个目标：**不卡 + 不乱**。  
> DoEvents 能救急，但要知道它的代价；最终要迁移到可控的 async/Task + 并发控制。

---

## Q&A 备选（剩余时间）
- 为什么 DoEvents 会让 bug 偶现？
- 为什么 await 后还能更新 UI？
- 为什么版本号通常比时间戳更可靠？
